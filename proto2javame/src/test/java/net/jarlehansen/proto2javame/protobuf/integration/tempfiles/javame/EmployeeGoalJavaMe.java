package net.jarlehansen.proto2javame.protobuf.integration.tempfiles.javame;
// Generated by proto2javame, Wed Jun 15 22:03:55 CEST 2011.

import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import net.jarlehansen.protobuf.javame.UninitializedMessageException;
import net.jarlehansen.protobuf.javame.input.InputReader;
import net.jarlehansen.protobuf.javame.input.DelimitedInputStream;
import net.jarlehansen.protobuf.javame.input.DelimitedSizeUtil;
import net.jarlehansen.protobuf.javame.ComputeSizeUtil;
import net.jarlehansen.protobuf.javame.output.OutputWriter;
import net.jarlehansen.protobuf.javame.AbstractOutputWriter;
import net.jarlehansen.protobuf.javame.input.taghandler.UnknownTagHandler;
import net.jarlehansen.protobuf.javame.input.taghandler.DefaultUnknownTagHandlerImpl;

public final class EmployeeGoalJavaMe extends AbstractOutputWriter {
	private static UnknownTagHandler unknownTagHandler = DefaultUnknownTagHandlerImpl.newInstance();

	private final float actualValue;
	private static final int fieldNumberActualValue = 1;
	private final boolean hasActualValue;

	private final java.util.Vector employeeGoalComments;
	private static final int fieldNumberEmployeeGoalComments = 2;

	private final int criticality;
	private static final int fieldNumberCriticality = 3;
	private final boolean hasCriticality;

	private final long dueDate;
	private static final int fieldNumberDueDate = 4;
	private final boolean hasDueDate;

	private final String key;
	private static final int fieldNumberKey = 5;
	private final boolean hasKey;

	private final String name;
	private static final int fieldNumberName = 6;
	private final boolean hasName;

	private final float percentCompleted;
	private static final int fieldNumberPercentCompleted = 7;
	private final boolean hasPercentCompleted;

	private final float percentProgress;
	private static final int fieldNumberPercentProgress = 8;
	private final boolean hasPercentProgress;

	private final long startDate;
	private static final int fieldNumberStartDate = 9;
	private final boolean hasStartDate;

	private final String status;
	private static final int fieldNumberStatus = 10;
	private final boolean hasStatus;

	private final float targetValue;
	private static final int fieldNumberTargetValue = 11;
	private final boolean hasTargetValue;

	private final String type;
	private static final int fieldNumberType = 12;
	private final boolean hasType;


	public static Builder newBuilder() {
		return new Builder();
	}

	private EmployeeGoalJavaMe(final Builder builder) {
		if (true) {
			this.actualValue = builder.actualValue;
			this.hasActualValue = builder.hasActualValue;
			this.employeeGoalComments = builder.employeeGoalComments;
			this.criticality = builder.criticality;
			this.hasCriticality = builder.hasCriticality;
			this.dueDate = builder.dueDate;
			this.hasDueDate = builder.hasDueDate;
			this.key = builder.key;
			this.hasKey = builder.hasKey;
			this.name = builder.name;
			this.hasName = builder.hasName;
			this.percentCompleted = builder.percentCompleted;
			this.hasPercentCompleted = builder.hasPercentCompleted;
			this.percentProgress = builder.percentProgress;
			this.hasPercentProgress = builder.hasPercentProgress;
			this.startDate = builder.startDate;
			this.hasStartDate = builder.hasStartDate;
			this.status = builder.status;
			this.hasStatus = builder.hasStatus;
			this.targetValue = builder.targetValue;
			this.hasTargetValue = builder.hasTargetValue;
			this.type = builder.type;
			this.hasType = builder.hasType;
		} else {
			throw new UninitializedMessageException("Not all required fields were included (false = not included in message), " + 
				"");
		}
	}

	public static class Builder {
		private float actualValue;
		private boolean hasActualValue = false;

		private java.util.Vector employeeGoalComments = new java.util.Vector();
		private boolean hasEmployeeGoalComments = false;

		private int criticality;
		private boolean hasCriticality = false;

		private long dueDate;
		private boolean hasDueDate = false;

		private String key;
		private boolean hasKey = false;

		private String name;
		private boolean hasName = false;

		private float percentCompleted;
		private boolean hasPercentCompleted = false;

		private float percentProgress;
		private boolean hasPercentProgress = false;

		private long startDate;
		private boolean hasStartDate = false;

		private String status;
		private boolean hasStatus = false;

		private float targetValue;
		private boolean hasTargetValue = false;

		private String type;
		private boolean hasType = false;


		private Builder() {
		}

		public Builder setActualValue(final float actualValue) {
			this.actualValue = actualValue;
			this.hasActualValue = true;
			return this;
		}

		public Builder setEmployeeGoalComments(final java.util.Vector employeeGoalComments) {
			if(!hasEmployeeGoalComments) {
				hasEmployeeGoalComments = true;
			}
			this.employeeGoalComments = employeeGoalComments;
			return this;
		}


		public Builder addElementEmployeeGoalComments(final EmployeeGoalCommentJavaMe element) {
			if(!hasEmployeeGoalComments) {
				hasEmployeeGoalComments = true;
			}
			employeeGoalComments.addElement(element);
			return this;
		}

		public Builder setCriticality(final int criticality) {
			this.criticality = criticality;
			this.hasCriticality = true;
			return this;
		}

		public Builder setDueDate(final long dueDate) {
			this.dueDate = dueDate;
			this.hasDueDate = true;
			return this;
		}

		public Builder setKey(final String key) {
			this.key = key;
			this.hasKey = true;
			return this;
		}

		public Builder setName(final String name) {
			this.name = name;
			this.hasName = true;
			return this;
		}

		public Builder setPercentCompleted(final float percentCompleted) {
			this.percentCompleted = percentCompleted;
			this.hasPercentCompleted = true;
			return this;
		}

		public Builder setPercentProgress(final float percentProgress) {
			this.percentProgress = percentProgress;
			this.hasPercentProgress = true;
			return this;
		}

		public Builder setStartDate(final long startDate) {
			this.startDate = startDate;
			this.hasStartDate = true;
			return this;
		}

		public Builder setStatus(final String status) {
			this.status = status;
			this.hasStatus = true;
			return this;
		}

		public Builder setTargetValue(final float targetValue) {
			this.targetValue = targetValue;
			this.hasTargetValue = true;
			return this;
		}

		public Builder setType(final String type) {
			this.type = type;
			this.hasType = true;
			return this;
		}

		public EmployeeGoalJavaMe build() {
			return new EmployeeGoalJavaMe(this);
		}
	}

	public float getActualValue() {
		return actualValue;
	}

	public boolean hasActualValue() {
		return hasActualValue;
	}

	public java.util.Vector getEmployeeGoalComments() {
		return employeeGoalComments;
	}

	public int getCriticality() {
		return criticality;
	}

	public boolean hasCriticality() {
		return hasCriticality;
	}

	public long getDueDate() {
		return dueDate;
	}

	public boolean hasDueDate() {
		return hasDueDate;
	}

	public String getKey() {
		return key;
	}

	public boolean hasKey() {
		return hasKey;
	}

	public String getName() {
		return name;
	}

	public boolean hasName() {
		return hasName;
	}

	public float getPercentCompleted() {
		return percentCompleted;
	}

	public boolean hasPercentCompleted() {
		return hasPercentCompleted;
	}

	public float getPercentProgress() {
		return percentProgress;
	}

	public boolean hasPercentProgress() {
		return hasPercentProgress;
	}

	public long getStartDate() {
		return startDate;
	}

	public boolean hasStartDate() {
		return hasStartDate;
	}

	public String getStatus() {
		return status;
	}

	public boolean hasStatus() {
		return hasStatus;
	}

	public float getTargetValue() {
		return targetValue;
	}

	public boolean hasTargetValue() {
		return hasTargetValue;
	}

	public String getType() {
		return type;
	}

	public boolean hasType() {
		return hasType;
	}

	public String toString() {
		final String TAB = "   ";
		String retValue = "";
		retValue += this.getClass().getName() + "(";
		if(hasActualValue) retValue += "actualValue = " + this.actualValue + TAB;
		retValue += "employeeGoalComments = " + this.employeeGoalComments + TAB;
		if(hasCriticality) retValue += "criticality = " + this.criticality + TAB;
		if(hasDueDate) retValue += "dueDate = " + this.dueDate + TAB;
		if(hasKey) retValue += "key = " + this.key + TAB;
		if(hasName) retValue += "name = " + this.name + TAB;
		if(hasPercentCompleted) retValue += "percentCompleted = " + this.percentCompleted + TAB;
		if(hasPercentProgress) retValue += "percentProgress = " + this.percentProgress + TAB;
		if(hasStartDate) retValue += "startDate = " + this.startDate + TAB;
		if(hasStatus) retValue += "status = " + this.status + TAB;
		if(hasTargetValue) retValue += "targetValue = " + this.targetValue + TAB;
		if(hasType) retValue += "type = " + this.type + TAB;
		retValue += ")";

		return retValue;
	}

	// Override
	public int computeSize() {
		int totalSize = 0;
		if(hasActualValue) totalSize += ComputeSizeUtil.computeFloatSize(fieldNumberActualValue, actualValue);
		if(hasCriticality) totalSize += ComputeSizeUtil.computeIntSize(fieldNumberCriticality, criticality);
		if(hasDueDate) totalSize += ComputeSizeUtil.computeLongSize(fieldNumberDueDate, dueDate);
		if(hasKey) totalSize += ComputeSizeUtil.computeStringSize(fieldNumberKey, key);
		if(hasName) totalSize += ComputeSizeUtil.computeStringSize(fieldNumberName, name);
		if(hasPercentCompleted) totalSize += ComputeSizeUtil.computeFloatSize(fieldNumberPercentCompleted, percentCompleted);
		if(hasPercentProgress) totalSize += ComputeSizeUtil.computeFloatSize(fieldNumberPercentProgress, percentProgress);
		if(hasStartDate) totalSize += ComputeSizeUtil.computeLongSize(fieldNumberStartDate, startDate);
		if(hasStatus) totalSize += ComputeSizeUtil.computeStringSize(fieldNumberStatus, status);
		if(hasTargetValue) totalSize += ComputeSizeUtil.computeFloatSize(fieldNumberTargetValue, targetValue);
		if(hasType) totalSize += ComputeSizeUtil.computeStringSize(fieldNumberType, type);
		totalSize += computeNestedMessageSize();

		return totalSize;
	}

	private int computeNestedMessageSize() {
		int messageSize = 0;
		messageSize += ComputeSizeUtil.computeListSize(fieldNumberEmployeeGoalComments, net.jarlehansen.protobuf.javame.SupportedDataTypes.DATA_TYPE_CUSTOM, employeeGoalComments);

		return messageSize;
	}

	// Override
	public void writeFields(final OutputWriter writer) throws IOException {
		if(hasActualValue) writer.writeFloat(fieldNumberActualValue, actualValue);
		writer.writeList(fieldNumberEmployeeGoalComments, net.jarlehansen.protobuf.javame.SupportedDataTypes.DATA_TYPE_CUSTOM, employeeGoalComments);
		if(hasCriticality) writer.writeInt(fieldNumberCriticality, criticality);
		if(hasDueDate) writer.writeLong(fieldNumberDueDate, dueDate);
		if(hasKey) writer.writeString(fieldNumberKey, key);
		if(hasName) writer.writeString(fieldNumberName, name);
		if(hasPercentCompleted) writer.writeFloat(fieldNumberPercentCompleted, percentCompleted);
		if(hasPercentProgress) writer.writeFloat(fieldNumberPercentProgress, percentProgress);
		if(hasStartDate) writer.writeLong(fieldNumberStartDate, startDate);
		if(hasStatus) writer.writeString(fieldNumberStatus, status);
		if(hasTargetValue) writer.writeFloat(fieldNumberTargetValue, targetValue);
		if(hasType) writer.writeString(fieldNumberType, type);
		writer.writeData();
	}

	static EmployeeGoalJavaMe parseFields(final InputReader reader) throws IOException {
		int nextFieldNumber = getNextFieldNumber(reader);
		final EmployeeGoalJavaMe.Builder builder = EmployeeGoalJavaMe.newBuilder();

		while (nextFieldNumber > 0) {
			if(!populateBuilderWithField(reader, builder, nextFieldNumber)) {
				reader.getPreviousTagDataTypeAndReadContent();
			}
			nextFieldNumber = getNextFieldNumber(reader);
		}

		return builder.build();
	}

	static int getNextFieldNumber(final InputReader reader) throws IOException {
		return reader.getNextFieldNumber();
	}

	static boolean populateBuilderWithField(final InputReader reader, final Builder builder, final int fieldNumber) throws IOException {
		boolean fieldFound = true;
		switch (fieldNumber) {
			case fieldNumberActualValue:
				builder.setActualValue(reader.readFloat(fieldNumber));
				break;
			case fieldNumberEmployeeGoalComments:
				Vector vcEmployeeGoalComments = reader.readMessages(fieldNumberEmployeeGoalComments);
				for(int i = 0 ; i < vcEmployeeGoalComments.size(); i++) {
					byte[] eachBinData = (byte[]) vcEmployeeGoalComments.elementAt(i);
					EmployeeGoalCommentJavaMe.Builder builderEmployeeGoalComments = EmployeeGoalCommentJavaMe.newBuilder();
					InputReader innerInputReader = new InputReader(eachBinData, unknownTagHandler);
					boolean boolEmployeeGoalComments = true;
					int nestedFieldEmployeeGoalComments = -1;
					while(boolEmployeeGoalComments) {
						nestedFieldEmployeeGoalComments = getNextFieldNumber(innerInputReader);
						boolEmployeeGoalComments = EmployeeGoalCommentJavaMe.populateBuilderWithField(innerInputReader, builderEmployeeGoalComments, nestedFieldEmployeeGoalComments);
					}
					eachBinData = null;
					innerInputReader = null;
					builder.addElementEmployeeGoalComments(builderEmployeeGoalComments.build());
				}
				break;
			case fieldNumberCriticality:
				builder.setCriticality(reader.readInt(fieldNumber));
				break;
			case fieldNumberDueDate:
				builder.setDueDate(reader.readLong(fieldNumber));
				break;
			case fieldNumberKey:
				builder.setKey(reader.readString(fieldNumber));
				break;
			case fieldNumberName:
				builder.setName(reader.readString(fieldNumber));
				break;
			case fieldNumberPercentCompleted:
				builder.setPercentCompleted(reader.readFloat(fieldNumber));
				break;
			case fieldNumberPercentProgress:
				builder.setPercentProgress(reader.readFloat(fieldNumber));
				break;
			case fieldNumberStartDate:
				builder.setStartDate(reader.readLong(fieldNumber));
				break;
			case fieldNumberStatus:
				builder.setStatus(reader.readString(fieldNumber));
				break;
			case fieldNumberTargetValue:
				builder.setTargetValue(reader.readFloat(fieldNumber));
				break;
			case fieldNumberType:
				builder.setType(reader.readString(fieldNumber));
				break;
		default:
			fieldFound = false;
		}
		return fieldFound;
	}

	public static void setUnknownTagHandler(final UnknownTagHandler unknownTagHandler) {
		EmployeeGoalJavaMe.unknownTagHandler = unknownTagHandler;
	}

	public static EmployeeGoalJavaMe parseFrom(final byte[] data) throws IOException {
		return parseFields(new InputReader(data, unknownTagHandler));
	}

	public static EmployeeGoalJavaMe parseFrom(final InputStream inputStream) throws IOException {
		return parseFields(new InputReader(inputStream, unknownTagHandler));
	}

	public static EmployeeGoalJavaMe parseDelimitedFrom(final InputStream inputStream) throws IOException {
		final int limit = DelimitedSizeUtil.readDelimitedSize(inputStream);
		return parseFields(new InputReader(new DelimitedInputStream(inputStream, limit), unknownTagHandler));
	}
}